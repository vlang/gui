---
phase: 01-fragment-shader-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shaders_glsl.v
  - shaders_metal.v
autonomous: true

must_haves:
  truths:
    - "GLSL fragment shader computes multi-stop gradient colors"
    - "Metal fragment shader computes multi-stop gradient colors"
    - "Dithering prevents visible color banding"
    - "Premultiplied alpha interpolation prevents gray artifacts"
  artifacts:
    - path: "shaders_glsl.v"
      provides: "vs_gradient_glsl and fs_gradient_glsl shader strings"
      contains: "vs_gradient_glsl"
    - path: "shaders_metal.v"
      provides: "vs_gradient_metal and fs_gradient_metal shader strings"
      contains: "vs_gradient_metal"
  key_links:
    - from: "fs_gradient_glsl"
      to: "tm uniform"
      via: "matrix rows as gradient stops"
      pattern: "tm\\[0\\]|tm\\[1\\]|tm\\[2\\]"
    - from: "fs_gradient_metal"
      to: "uniforms.tm"
      via: "matrix rows as gradient stops"
      pattern: "uniforms\\.tm\\[0\\]|uniforms\\.tm\\[1\\]"
---

<objective>
Create GLSL and Metal fragment shaders for multi-stop gradient rendering with dithering.

Purpose: Foundation for GPU-computed gradients replacing 2-stop vertex interpolation hack
Output: Four shader source strings (vs/fs for each backend) ready for pipeline init
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-fragment-shader-foundation/01-RESEARCH.md

# Existing shader patterns to follow
@shaders_glsl.v
@shaders_metal.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GLSL gradient shaders</name>
  <files>shaders_glsl.v</files>
  <action>
Add vs_gradient_glsl and fs_gradient_glsl shader source strings to shaders_glsl.v.

**Vertex shader (vs_gradient_glsl):**
- Follow vs_shadow_glsl pattern exactly
- Accept position (float3), texcoord0 (float2), color0 (float4)
- Uniforms: mvp (mat4), tm (mat4)
- Output: uv, color, params (from position.z)
- tm matrix passes gradient stop data to fragment shader

**Fragment shader (fs_gradient_glsl):**
- Unpack radius from params (floor(params / 1000.0))
- Unpack stop_count from params (mod(params, 1000.0))
- Read gradient stops from tm matrix rows:
  - tm[0] = vec4(r1, g1, b1, pos1) - stop 1
  - tm[1] = vec4(r2, g2, b2, pos2) - stop 2
  - tm[2] = vec4(r3, g3, b3, pos3) - stop 3
  - Colors are 0.0-1.0, positions are 0.0-1.0
- Compute gradient position t from uv.x: t = uv.x * 0.5 + 0.5 (maps -1..1 to 0..1)
- Multi-stop interpolation: find which segment t falls in, lerp between stops
- Use premultiplied alpha interpolation (see RESEARCH.md Pitfall 5):
  ```glsl
  vec3 c1_pre = c1.rgb * c1.a;
  vec3 c2_pre = c2.rgb * c2.a;
  vec3 rgb_pre = mix(c1_pre, c2_pre, local_t);
  float alpha = mix(c1.a, c2.a, local_t);
  vec3 rgb = rgb_pre / max(alpha, 0.0001);
  ```
- Add dithering before final output:
  ```glsl
  float random(vec2 coords) {
      return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);
  }
  float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;
  gradient_color.rgb += vec3(dither);
  ```
- Compute SDF for rounded rect clipping (copy from fs_glsl pattern)
- Combine: frag_color = vec4(gradient_color.rgb, gradient_color.a * sdf_alpha)
- Include sgl texture workaround (if frag_color.a < 0.0)

Do NOT use precision qualifiers (existing shaders don't use them, desktop-only target).
  </action>
  <verify>v -check-syntax shaders_glsl.v compiles without errors</verify>
  <done>vs_gradient_glsl and fs_gradient_glsl strings defined in shaders_glsl.v</done>
</task>

<task type="auto">
  <name>Task 2: Create Metal gradient shaders</name>
  <files>shaders_metal.v</files>
  <action>
Add vs_gradient_metal and fs_gradient_metal shader source strings to shaders_metal.v.

**Vertex shader (vs_gradient_metal):**
- Follow vs_shadow_metal pattern exactly
- VertexIn: position (float3), texcoord0 (float2), color0 (float4)
- VertexOut: position, uv, color, params
- Uniforms struct: mvp (float4x4), tm (float4x4)
- Pass position.z to params output

**Fragment shader (fs_gradient_metal):**
- Unpack radius: floor(in.params / 1000.0)
- Unpack stop_count: fmod(in.params, 1000.0)
- Read gradient stops from uniforms.tm matrix columns (Metal is column-major):
  - uniforms.tm[0] = float4(r1, g1, b1, pos1)
  - uniforms.tm[1] = float4(r2, g2, b2, pos2)
  - uniforms.tm[2] = float4(r3, g3, b3, pos3)
- Compute gradient position t from in.uv.x: t = in.uv.x * 0.5 + 0.5
- Multi-stop interpolation with premultiplied alpha (same algorithm as GLSL)
- Add dithering using Metal's position attribute:
  ```metal
  float random(float2 coords) {
      return fract(sin(dot(coords, float2(12.9898, 78.233))) * 43758.5453);
  }
  float dither = (random(in.position.xy) - 0.5) / 255.0;
  ```
- SDF rounded rect clipping (copy from fs_metal pattern)
- Combine with SDF alpha
- Include texture workaround (if frag_color.a < 0.0)

Note: Metal uses fmod() not mod(), dfdx/dfdy not dFdx/dFdy.
  </action>
  <verify>v -check-syntax shaders_metal.v compiles without errors</verify>
  <done>vs_gradient_metal and fs_gradient_metal strings defined in shaders_metal.v</done>
</task>

</tasks>

<verification>
1. Both shader source files compile with V syntax check
2. Shader strings follow existing naming convention (vs_*_glsl/metal, fs_*_glsl/metal)
3. Both shaders read tm matrix for stop data
4. Both shaders implement dithering
5. Both shaders use premultiplied alpha interpolation
</verification>

<success_criteria>
- vs_gradient_glsl, fs_gradient_glsl defined in shaders_glsl.v
- vs_gradient_metal, fs_gradient_metal defined in shaders_metal.v
- Shader sources follow established patterns (uniform layout, vertex attributes)
- Multi-stop interpolation supports 3 stops via tm matrix
- Dithering implemented to prevent banding
- Premultiplied alpha interpolation prevents gray artifacts
</success_criteria>

<output>
After completion, create `.planning/phases/01-fragment-shader-foundation/01-01-SUMMARY.md`
</output>
