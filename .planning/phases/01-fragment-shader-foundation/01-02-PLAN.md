---
phase: 01-fragment-shader-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - window.v
  - shaders.v
autonomous: true

must_haves:
  truths:
    - "Window struct has gradient_pip and gradient_pip_init fields"
    - "init_gradient_pipeline creates valid sokol pipeline"
    - "Pipeline uses tm uniform for gradient stop data"
  artifacts:
    - path: "window.v"
      provides: "gradient_pip and gradient_pip_init fields in Window struct"
      contains: "gradient_pip"
    - path: "shaders.v"
      provides: "init_gradient_pipeline function"
      contains: "fn init_gradient_pipeline"
  key_links:
    - from: "shaders.v"
      to: "shaders_glsl.v"
      via: "shader source reference"
      pattern: "vs_gradient_glsl|fs_gradient_glsl"
    - from: "shaders.v"
      to: "shaders_metal.v"
      via: "shader source reference"
      pattern: "vs_gradient_metal|fs_gradient_metal"
    - from: "shaders.v"
      to: "window.v"
      via: "pipeline field access"
      pattern: "window\\.gradient_pip"
---

<objective>
Create gradient pipeline infrastructure following shadow_pip/blur_pip patterns.

Purpose: Establish GPU pipeline that connects shader sources to rendering system
Output: init_gradient_pipeline() function and Window struct fields ready for use
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-fragment-shader-foundation/01-RESEARCH.md
@.planning/phases/01-fragment-shader-foundation/01-01-SUMMARY.md

# Existing pipeline patterns
@shaders.v
@window.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add gradient pipeline fields to Window struct</name>
  <files>window.v</files>
  <action>
Add two fields to the Window struct, following the existing shadow_pip/blur_pip pattern.

In window.v, locate the Window struct (around line 17) and add after blur_pip_init:

```v
gradient_pip      sgl.Pipeline         // Pipeline for drawing multi-stop gradients
gradient_pip_init bool                 // Initialization flag for gradient pipeline
```

Place them after the blur_pip fields to maintain logical grouping of rendering pipelines.
  </action>
  <verify>v -check-syntax window.v compiles without errors</verify>
  <done>Window struct contains gradient_pip and gradient_pip_init fields</done>
</task>

<task type="auto">
  <name>Task 2: Create init_gradient_pipeline function</name>
  <files>shaders.v</files>
  <action>
Add init_gradient_pipeline() function to shaders.v, following init_shadow_pipeline() pattern exactly.

Place after init_blur_pipeline() function. The function should:

1. **Guard clause:** Return early if window.gradient_pip_init is true

2. **Vertex attributes (identical to shadow/blur):**
   - attrs[0]: position (float3, offset 0)
   - attrs[1]: texcoord0 (float2, offset 12)
   - attrs[2]: color0 (ubyte4n, offset 20)
   - Buffer stride: 24

3. **Shader attributes (identical):**
   - position -> POSITION sem_index 0
   - texcoord0 -> TEXCOORD sem_index 0
   - color0 -> COLOR sem_index 0

4. **Uniform block (identical to shadow - has tm):**
   - mvp (mat4, array_count 1)
   - tm (mat4, array_count 1)
   - Block size: 128 bytes

5. **Color targets (identical - alpha blending):**
   - blend enabled, src_alpha / one_minus_src_alpha

6. **Images/Samplers (identical - sgl requirement):**
   - shader_images[0]: 2d, float sample_type
   - shader_samplers[0]: filtering
   - shader_image_sampler_pairs[0]: image_slot 0, sampler_slot 0, glsl_name "tex"

7. **Shader description:**
   - $if macos: vs_gradient_metal, fs_gradient_metal, entry c'vs_main'/c'fs_main'
   - $else: vs_gradient_glsl, fs_gradient_glsl

8. **Pipeline description:**
   - label: c'gradient_pip'
   - Assemble with gfx.make_shader(&shader_desc)

9. **Set fields:**
   - window.gradient_pip = sgl.make_pipeline(&desc)
   - window.gradient_pip_init = true

**Critical:** The tm uniform is what carries gradient stop data. This must be declared
in the uniform block (it is - same as shadow_pip).
  </action>
  <verify>v -check-syntax shaders.v compiles without errors</verify>
  <done>init_gradient_pipeline function exists and follows shadow_pip pattern</done>
</task>

</tasks>

<verification>
1. v -check-syntax window.v passes
2. v -check-syntax shaders.v passes
3. init_gradient_pipeline references vs_gradient_glsl/metal, fs_gradient_glsl/metal
4. Pipeline uses identical vertex layout to shadow_pip (position, texcoord0, color0)
5. Uniform block includes tm matrix for gradient data
</verification>

<success_criteria>
- Window struct has gradient_pip (sgl.Pipeline) and gradient_pip_init (bool) fields
- init_gradient_pipeline() exists in shaders.v
- Function follows lazy-init pattern (early return if already init)
- Shader sources referenced via $if macos conditional
- Pipeline labeled 'gradient_pip'
- tm uniform available for gradient stop data
</success_criteria>

<output>
After completion, create `.planning/phases/01-fragment-shader-foundation/01-02-SUMMARY.md`
</output>
