---
phase: 01-fragment-shader-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - render.v
autonomous: false

must_haves:
  truths:
    - "draw_gradient_rect uses gradient_pip not rounded_rect_pip"
    - "Gradient stops packed into tm matrix"
    - "3-stop gradients render correctly on macOS (Metal)"
    - "3-stop gradients render correctly on Linux (GLSL)"
  artifacts:
    - path: "render.v"
      provides: "Updated draw_gradient_rect using gradient pipeline"
      contains: "init_gradient_pipeline"
  key_links:
    - from: "render.v"
      to: "shaders.v"
      via: "pipeline initialization call"
      pattern: "init_gradient_pipeline\\(mut window\\)"
    - from: "render.v"
      to: "tm matrix"
      via: "sgl matrix operations"
      pattern: "sgl\\.matrix_mode_texture|sgl\\.load_identity"
---

<objective>
Wire draw_gradient_rect to use the new gradient pipeline with multi-stop support.

Purpose: Replace 2-stop vertex interpolation HACK with fragment shader pipeline
Output: Working multi-stop gradients visible in gradient_demo example
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-fragment-shader-foundation/01-RESEARCH.md
@.planning/phases/01-fragment-shader-foundation/01-01-SUMMARY.md
@.planning/phases/01-fragment-shader-foundation/01-02-SUMMARY.md

# Current implementation to modify
@render.v
@shaders.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update draw_gradient_rect to use gradient pipeline</name>
  <files>render.v</files>
  <action>
Modify the existing draw_gradient_rect() function (around line 810) to use the gradient pipeline
instead of rounded_rect_pip with vertex color interpolation.

**Replace the current implementation with:**

1. **Keep existing guards and scaling:**
   ```v
   if w <= 0 || h <= 0 {
       return
   }
   scale := window.ui.scale
   sx := x * scale
   sy := y * scale
   sw := w * scale
   sh := h * scale
   mut r := radius * scale
   // Keep radius clamping logic
   ```

2. **Initialize gradient pipeline:**
   ```v
   init_gradient_pipeline(mut window)
   ```

3. **Pack gradient stops into tm matrix via sgl:**
   Follow the shadow_rect pattern of using sgl.matrix_mode_texture():
   ```v
   sgl.matrix_mode_texture()
   sgl.push_matrix()
   sgl.load_identity()
   ```

   The tm matrix is 4x4 = 16 floats. Pack up to 3 stops:
   - Row 0: stop 0 (r, g, b, position)
   - Row 1: stop 1 (r, g, b, position)
   - Row 2: stop 2 (r, g, b, position)
   - Row 3: reserved (set to 0)

   **Problem:** sgl only has translate/rotate/scale, not arbitrary matrix set.
   **Solution:** Use sgl.mult_matrix() with our stop data packed as a matrix.

   Create a helper or inline the matrix construction:
   ```v
   mut tm_data := [16]f32{}
   stop_count := if gradient.stops.len > 3 { 3 } else { gradient.stops.len }
   for i in 0..stop_count {
       stop := gradient.stops[i]
       // Column-major order for sgl/sokol
       tm_data[i * 4 + 0] = f32(stop.color.r) / 255.0
       tm_data[i * 4 + 1] = f32(stop.color.g) / 255.0
       tm_data[i * 4 + 2] = f32(stop.color.b) / 255.0
       tm_data[i * 4 + 3] = stop.pos
   }
   // If < 3 stops, pad with last stop
   if stop_count < 3 {
       last := gradient.stops.last()
       for i in stop_count..3 {
           tm_data[i * 4 + 0] = f32(last.color.r) / 255.0
           tm_data[i * 4 + 1] = f32(last.color.g) / 255.0
           tm_data[i * 4 + 2] = f32(last.color.b) / 255.0
           tm_data[i * 4 + 3] = 1.0
       }
   }
   // sgl.mult_matrix expects pointer to 16 floats
   sgl.mult_matrix(unsafe { &tm_data[0] })
   ```

4. **Load pipeline and draw:**
   ```v
   sgl.load_pipeline(window.gradient_pip)
   sgl.c4b(255, 255, 255, 255)  // White base color (shader computes actual color)

   z_val := pack_shader_params(r, f32(stop_count))
   draw_quad(sx, sy, sw, sh, z_val)

   sgl.load_default_pipeline()
   sgl.pop_matrix()
   sgl.matrix_mode_modelview()
   ```

**Remove:** The HACK comment and the old draw_quad_gradient call.
**Keep:** draw_quad_gradient function for now (border gradient still uses it).

**Important:** Test with gradient_demo.v example which uses 2-stop gradients.
The shader should handle 2 stops correctly (third stop padded to position 1.0).
  </action>
  <verify>
v -check-syntax render.v
v run examples/gradient_demo.v (visual check - should show gradient rects)
  </verify>
  <done>draw_gradient_rect uses gradient_pip and packs stops into tm matrix</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Fragment shader gradient pipeline replacing vertex interpolation:
- GLSL and Metal shaders with multi-stop support
- Gradient pipeline (gradient_pip) in Window struct
- draw_gradient_rect modified to use new pipeline
- Dithering to prevent color banding
- Premultiplied alpha interpolation
  </what-built>
  <how-to-verify>
1. Run gradient demo:
   ```
   v run examples/gradient_demo.v
   ```

2. Verify on macOS (Metal backend):
   - Gradient rects render (not black, not corrupted)
   - Colors transition smoothly from left to right
   - No visible color banding in transitions
   - Rounded corners clip correctly

3. If Linux available, verify GLSL backend produces identical output

4. Test with existing gradient examples:
   ```
   v run examples/gradient_border_demo.v
   ```
   Note: Border gradients still use old method (expected for Phase 1)

5. Look for any artifacts:
   - Gray tint when fading to transparency (premultiplied alpha issue)
   - Harsh color bands (dithering not working)
   - Upside-down gradients (coordinate system issue)
  </how-to-verify>
  <resume-signal>Type "approved" if gradients render correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. render.v compiles without errors
2. gradient_demo.v runs without crash
3. Gradient rectangles visible (not black/corrupted)
4. Smooth color transitions (dithering working)
5. Rounded corners clip correctly
</verification>

<success_criteria>
- draw_gradient_rect calls init_gradient_pipeline
- Gradient stops packed into tm matrix (up to 3 stops)
- stop_count passed via z-coordinate packing
- Visual verification: gradient_demo.v shows smooth gradients
- No color banding artifacts
- Both Metal (macOS) and GLSL (Linux) backends produce correct output
</success_criteria>

<output>
After completion, create `.planning/phases/01-fragment-shader-foundation/01-03-SUMMARY.md`
</output>
