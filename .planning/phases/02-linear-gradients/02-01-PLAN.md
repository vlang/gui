---
phase: 02-linear-gradients
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - styles.v
  - render.v
autonomous: true

must_haves:
  truths:
    - "Gradient struct accepts direction enum or explicit angle"
    - "Direction keywords map to correct CSS angles"
    - "Corner keywords adjust for element aspect ratio"
    - "Default direction is to_bottom (180deg) matching CSS"
  artifacts:
    - path: "styles.v"
      provides: "Direction enum and Gradient.angle field"
      contains: "Direction"
    - path: "render.v"
      provides: "Direction vector computation and tm[3] packing"
      contains: "angle_to_direction"
  key_links:
    - from: "render.v"
      to: "styles.v"
      via: "Direction enum import"
      pattern: "gradient\\.direction"
    - from: "render.v"
      to: "tm_data\\[12\\]"
      via: "direction vector packing"
      pattern: "tm_data\\[12\\].*=.*dx"
---

<objective>
Add direction/angle support to Gradient struct and compute direction vectors in render.v

Purpose: Enable users to specify gradient angle via degrees or CSS keywords
Output: Direction enum, angle field, tm[3] packing with direction vector
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-linear-gradients/02-CONTEXT.md
@.planning/phases/02-linear-gradients/02-RESEARCH.md
@styles.v
@render.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Direction enum and angle field to Gradient struct</name>
  <files>styles.v</files>
  <action>
Add Direction enum after GradientType enum:

```v
pub enum Direction {
    to_top
    to_top_right
    to_right
    to_bottom_right
    to_bottom
    to_bottom_left
    to_left
    to_top_left
}
```

Update Gradient struct to add direction and angle fields:

```v
pub struct Gradient {
pub:
    stops     []GradientStop
    start_x   f32  // deprecated, kept for compatibility
    start_y   f32
    end_x     f32
    end_y     f32
    type      GradientType = .linear
    direction Direction    = .to_bottom  // CSS default
    angle     ?f32         // Optional explicit angle (degrees), overrides direction
}
```

Key points:
- Direction default is .to_bottom (180deg) per CSS spec
- angle is optional (?f32) - when set, overrides direction keyword
- Keep start_x/end_x for backward compatibility (deprecated)

Format with: `v fmt -w styles.v`
  </action>
  <verify>`v -check-syntax styles.v` passes with no errors</verify>
  <done>Direction enum exists with 8 values, Gradient has direction and angle fields</done>
</task>

<task type="auto">
  <name>Task 2: Compute direction vector and pack into tm[3]</name>
  <files>render.v</files>
  <action>
Add helper functions before draw_gradient_rect:

```v
import math

// angle_to_direction converts CSS angle (degrees) to unit direction vector
// CSS: 0deg=top, clockwise. Math: 0rad=right, counter-clockwise.
fn angle_to_direction(css_degrees f32) (f32, f32) {
    rad := (90.0 - css_degrees) * math.pi / 180.0
    return f32(math.cos(rad)), f32(math.sin(rad))
}

// gradient_direction computes direction vector from Gradient config
// Handles both explicit angle and direction keywords
fn gradient_direction(gradient &Gradient, width f32, height f32) (f32, f32) {
    // If explicit angle provided, use it
    if angle := gradient.angle {
        return angle_to_direction(angle)
    }

    // Convert direction keyword to angle
    css_angle := match gradient.direction {
        .to_top         { f32(0.0) }
        .to_right       { f32(90.0) }
        .to_bottom      { f32(180.0) }
        .to_left        { f32(270.0) }
        .to_top_right   { 90.0 - f32(math.atan2(height, width)) * 180.0 / math.pi }
        .to_bottom_right{ 90.0 + f32(math.atan2(height, width)) * 180.0 / math.pi }
        .to_bottom_left { 270.0 - f32(math.atan2(height, width)) * 180.0 / math.pi }
        .to_top_left    { 270.0 + f32(math.atan2(height, width)) * 180.0 / math.pi }
    }
    return angle_to_direction(css_angle)
}
```

Update draw_gradient_rect to pack direction into tm[3]:

After the stop packing loop (after line ~856), add:

```v
    // Compute direction vector and pack into tm[3]
    dx, dy := gradient_direction(gradient, sw, sh)
    tm_data[12] = dx  // tm[3].x = cos(math_angle)
    tm_data[13] = dy  // tm[3].y = sin(math_angle)
    tm_data[14] = 0.0
    // tm_data[15] already set to 1.0
```

Note: math module may already be imported; if not, add `import math` at top.

Format with: `v fmt -w render.v`
  </action>
  <verify>`v -check-syntax render.v` passes and `v .` compiles the module</verify>
  <done>gradient_direction() computes direction, tm[3] contains direction vector</done>
</task>

</tasks>

<verification>
- `v -check-syntax styles.v` - no errors
- `v -check-syntax render.v` - no errors
- `v .` in gui directory compiles without errors
- Direction enum has 8 values matching CSS keywords
- Gradient struct has direction (default .to_bottom) and angle (?f32) fields
- draw_gradient_rect packs direction into tm[3].xy
</verification>

<success_criteria>
- V code compiles without errors
- Direction enum defined with all 8 CSS keywords
- Gradient struct extended with direction and optional angle
- gradient_direction() handles both angle and keyword cases
- Corner keywords use atan2 for aspect-ratio-aware angles
- tm[3].xy packed with direction vector (dx, dy)
</success_criteria>

<output>
After completion, create `.planning/phases/02-linear-gradients/02-01-SUMMARY.md`
</output>
