---
phase: 03-radial-gradients
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - render.v
autonomous: true

must_haves:
  truths:
    - "Radial gradient type detected and handled differently than linear"
    - "Aspect ratio computed for perfect circles on any rectangle"
    - "Gradient type flag passed to shader via tm[3].z"
  artifacts:
    - path: "render.v"
      provides: "Radial gradient parameter packing"
      contains: "gradient.type == .radial"
  key_links:
    - from: "render.v draw_gradient_rect"
      to: "tm[3]"
      via: "aspect ratio and type flag packing"
      pattern: "tm_data\\[14\\].*1\\.0"
---

<objective>
Pack radial gradient parameters (aspect ratio, type flag) into tm matrix for shader consumption.

Purpose: Enable shaders to distinguish radial from linear gradients and render perfect circles
regardless of element aspect ratio.

Output: Modified draw_gradient_rect that packs aspect_x, aspect_y into tm[3].xy and type flag
(1.0 = radial) into tm[3].z when gradient.type is .radial.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-radial-gradients/03-RESEARCH.md

@render.v (draw_gradient_rect function, lines 840-908)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modify draw_gradient_rect for radial gradients</name>
  <files>render.v</files>
  <action>
In draw_gradient_rect (around line 888-893), replace the unconditional direction packing with a
branch on gradient type:

```v
// tm[3] content depends on gradient type
if gradient.type == .radial {
    // Aspect ratio for perfect circles (closest-side sizing)
    // Scale the LONGER axis to 1.0, shorter axis gets ratio
    aspect_x := if sw >= sh { f32(1.0) } else { sw / sh }
    aspect_y := if sh >= sw { f32(1.0) } else { sh / sw }
    tm_data[12] = aspect_x  // tm[3].x
    tm_data[13] = aspect_y  // tm[3].y
    tm_data[14] = 1.0       // Radial flag (shader checks > 0.5)
    tm_data[15] = 1.0
} else {
    // Linear gradient (existing code)
    dx, dy := gradient_direction(gradient, sw, sh)
    tm_data[12] = dx
    tm_data[13] = dy
    tm_data[14] = 0.0       // Linear flag
    tm_data[15] = 1.0
}
```

Key points:
- For radial: aspect correction ensures length(uv * aspect) = 1.0 at closest edge
- tm[3].z = 1.0 signals radial mode to shader (linear has 0.0)
- Existing linear gradient path preserved with explicit 0.0 flag
  </action>
  <verify>
Run `v -check-syntax render.v` to verify no syntax errors.
Run `v fmt -w render.v` to format.
Run `v .` in project root to compile.
  </verify>
  <done>
draw_gradient_rect branches on gradient.type, packs aspect ratio for radial or direction for
linear, and sets tm[3].z type flag appropriately.
  </done>
</task>

</tasks>

<verification>
- `v -check-syntax render.v` passes
- `v .` compiles without errors
- Existing linear gradients still work (run any existing gradient demo)
</verification>

<success_criteria>
- Radial gradients pack aspect ratio into tm[3].xy
- Radial gradients set tm[3].z = 1.0 (type flag)
- Linear gradients unchanged, with tm[3].z = 0.0
- Code compiles and runs
</success_criteria>

<output>
After completion, create `.planning/phases/03-radial-gradients/03-01-SUMMARY.md`
</output>
